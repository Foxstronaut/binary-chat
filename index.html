<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LumenSync P2P</title>
    <style>
        :root { --glow: #00ff41; --bg: #000; }
        body { margin: 0; background: var(--bg); color: var(--glow); font-family: 'Courier New', monospace; display: flex; flex-direction: column; height: 100vh; }
        
        /* The Flashing Area */
        #surface { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; text-align: center; transition: background 0.05s; border: 2px solid #222; margin: 10px; border-radius: 8px; }
        #surface.active-flash { background: #fff !important; color: #000 !important; }
        
        /* UI Elements */
        .controls { padding: 15px; background: #111; display: flex; flex-direction: column; gap: 10px; }
        button { background: #111; color: var(--glow); border: 2px solid var(--glow); padding: 18px; font-weight: bold; border-radius: 8px; font-size: 1rem; }
        button:active { background: var(--glow); color: #000; }
        
        #video { position: fixed; top: 20px; right: 20px; width: 80px; height: 60px; border: 2px solid #333; border-radius: 4px; z-index: 100; background: #222; }
        #status { padding: 10px; font-size: 0.8rem; border-bottom: 1px solid #333; }
        .hidden { display: none; }
    </style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>

<div id="status">STATUS: OFFLINE</div>

<div id="surface">
    1. TAP "ENABLE CAMERA"<br>
    2. ACCEPT PERMISSIONS
</div>

<div class="controls">
    <button id="camBtn">ENABLE CAMERA</button>
    <button id="syncBtn" class="hidden">START OPTICAL SYNC</button>
</div>

<script>
    const video = document.getElementById('video');
    const surface = document.getElementById('surface');
    const camBtn = document.getElementById('camBtn');
    const syncBtn = document.getElementById('syncBtn');
    const status = document.getElementById('status');

    let videoTrack = null;
    let lastLuma = 0;

    // STEP 1: Explicit Camera Request
    camBtn.onclick = async () => {
        status.innerText = "STATUS: REQUESTING ACCESS...";
        try {
            // Requesting specifically for 'environment' (back camera)
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: { exact: "environment" },
                    width: { ideal: 640 }
                } 
            }).catch(async () => {
                // Fallback for desktop or devices with only one camera
                return await navigator.mediaDevices.getUserMedia({ video: true });
            });

            video.srcObject = stream;
            videoTrack = stream.getVideoTracks()[0];
            
            // Critical for mobile: Ensure video is actually playing
            await video.play();
            
            status.innerText = "STATUS: CAMERA ACTIVE";
            camBtn.classList.add('hidden');
            syncBtn.classList.remove('hidden');
            surface.innerText = "CAMERA READY. POINT AT PEER AND START SYNC.";
            
        } catch (err) {
            status.innerText = "STATUS: ACCESS DENIED";
            alert("Please allow camera access in your browser settings and refresh.");
        }
    };

    // STEP 2: The Logic (Flashing + Listening)
    syncBtn.onclick = async () => {
        status.innerText = "STATUS: PAIRING...";
        surface.innerText = "PAIRING...";

        // Pulse the pairing code
        const pairInterval = setInterval(() => transmit("1011"), 2000);

        // Analyze light
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        canvas.width = 30; canvas.height = 30;

        const scanLoop = setInterval(() => {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.drawImage(video, 0, 0, 30, 30);
                const frame = ctx.getImageData(0, 0, 30, 30).data;
                
                let brightness = 0;
                for (let i = 0; i < frame.length; i += 4) {
                    brightness += (frame[i] + frame[i+1] + frame[i+2]) / 3;
                }
                brightness /= (frame.length / 4);

                if (brightness - lastLuma > 35) { // Flash detected
                    clearInterval(pairInterval);
                    clearInterval(scanLoop);
                    startDataTransfer();
                }
                lastLuma = brightness;
            }
        }, 50);
    };

    async function transmit(bits) {
        for (let bit of bits) {
            const on = bit === '1';
            surface.className = on ? 'active-flash' : '';
            
            // Try torch toggle
            if (videoTrack && videoTrack.getCapabilities().torch) {
                try { await videoTrack.applyConstraints({ advanced: [{ torch: on }] }); } catch(e) {}
            }
            await new Promise(r => setTimeout(r, 150));
        }
        surface.className = '';
    }

    async function startDataTransfer() {
        status.innerText = "STATUS: SYNCED - TRANSFERRING";
        surface.innerText = "SENDING DATA...";
        await transmit("11100110");
        
        status.innerText = "STATUS: VERIFYING HASH";
        surface.innerText = "RECEIVING HASH...";
        await new Promise(r => setTimeout(r, 1500));
        
        status.innerText = "STATUS: COMPLETE";
        surface.innerText = "SUCCESSFUL TRANSFER";
    }
</script>
</body>
</html>
